var isNumeric=function(a){return"undefined"==typeof a?void 0:!Array.isArray(a)&&!isNaN(parseFloat(a))&&isFinite(a)},sumExact=function(a){var b=Math.abs;if(0==a.length)return;if(1==a.length)return a[0];let c=a[0],d=0,e=0;for(let f=1;f<a.length;f++){let g=a[f],h=c+g;if(-1<(g+"").indexOf(".")){let a=(g+"").split(".")[1].length;e=a>e?a:e}d+=b(c)>=b(g)?c-h+g:g-h+c,c=h}let f=Math.pow(10,e+1);return Math.round((c+d)*f)/f};class Matrix{constructor(a=[],b,c){if(this.rows=b||void 0,this.cols=c||void 0,this.values=[],0<a.length){let d=0===a.filter(a=>Array.isArray(a)).length;if(!d||"undefined"!=typeof b&&"undefined"!=typeof c)this.fill(a);else throw new Exception("The shape of the matrix could not be determined because the Matrix class was constructed with a flat data array and without the rows and/or cols parameter. Either construct the Matrix class with a two-dimensional array of data in a well-defined shape, or pass the rows and cols parameter on initialisation.")}}fill(a){let b=0===a.filter(a=>Array.isArray(a)).length;if(b)for(let b,c=0;c<this.rows;c++){b=[];for(let d=0;d<this.cols;d++)b[d]=a[c*this.cols+d]||0;this.values[c]=b}else{let b=0===a.filter(b=>b.length!==a[0].length).length;if(!b){throw new Exception("The shape of the matrix could not be determined because the rows are not of the same length.")}this.rows=a.length,this.cols=a[0].length,this.values=a}return this}static submatrix(a,b,c){let d,e=Matrix.clone(a);for(e.values.splice(b,1),d=e.values.length;d--;)e.values[d].splice(c,1);return e.rows=e.cols=e.values.length,e}static determinant(a){if(a.rows!==a.cols)return;if(0==a.rows)return 0;if(1==a.rows)return a.values[0][0];if(2==a.rows)return a.values[0][0]*a.values[1][1]-a.values[0][1]*a.values[1][0];let b=0;for(let c=0;1>c;c++)for(let d,e=0;e<a.rows;e++)d=(c+e)%2?-1:1,b+=d*a.values[c][e]*Matrix.determinant(Matrix.submatrix(a,c,e));return b}static clone(a){return JSON.parse(JSON.stringify(a))}determinant(){return Matrix.determinant(this)}submatrix(a,b){return Matrix.submatrix(this,a,b)}clone(){return Matrix.clone(this)}}class Vector{constructor(...a){let b=0;a.forEach(function(a){if(isNumeric(a)){let c=Vector.getDimensionLabel(b);this[c]=parseFloat(a),b++}else null!==a&&"object"==typeof a&&this.parseSettings(a)},this),this.x=this.x||0,this.y=this.y||0}parseSettings(a){if(a.dimension&&this.dimension<a.dimension)for(let b,c=this.dimension;c<a.dimension;c++)b=Vector.getDimensionLabel(c),this[b]=0}static getDimensionLabel(a){let b=Array(26).fill("").map((a,b)=>String.fromCharCode(97+b)),c=b.slice(-3).concat(b.slice(0,-3));return 25>=a?c[a]:b[Math.floor(a/25)-1]+b[a%25]}static getAngleLabel(a){let b=["alpha","beta","gamma","delta","epsilon","zeta","eta","theta","iota","kappa","lambda","mu","nu","xi","omicron","pi","rho","sigma","tau","upsilon","phi","chi","psi","omega"];return 23>=a?b[a]:b[Math.floor(a/23)-1]+b[a%23]}static sameDimension(a,...b){return 0==b.filter(b=>b.dimension!==a.dimension).length}static add(...a){if(Vector.sameDimension(...a)){let b=Array(a[0].dimension).fill(null).map((b,c)=>a.reduce((a,b)=>a+b[Vector.getDimensionLabel(c)],0));return new Vector(...b)}}static addExact(...a){if(Vector.sameDimension(...a)){let b=Array(a[0].dimension).fill(null).map((b,c)=>sumExact(a.map(a=>a[Vector.getDimensionLabel(c)])));return new Vector(...b)}}static subtract(a,...b){if(Vector.sameDimension(a,...b)){let c=Array(a.dimension).fill(null).map((c,d)=>b.reduce((a,b)=>a-b[Vector.getDimensionLabel(d)],a[Vector.getDimensionLabel(d)]));return new Vector(...c)}}static subtractExact(...a){if(Vector.sameDimension(...a)){let b=Array(a[0].dimension).fill(null).map((b,c)=>sumExact(a.map((a,b)=>0==b?a[Vector.getDimensionLabel(c)]:-a[Vector.getDimensionLabel(c)])));return new Vector(...b)}}static mult(a,b){let c=Array(a.dimension).fill(null).map((c,d)=>a[Vector.getDimensionLabel(d)]*b);return new Vector(...c)}static div(a,b){if(0!=b){let c=Array(a.dimension).fill(null).map((c,d)=>a[Vector.getDimensionLabel(d)]/b);return new Vector(...c)}}static negative(a){return Vector.mult(a,-1)}static dot(a,b){return Vector.sameDimension(a,b)?Array(a.dimension).fill(null).map((c,d)=>a[Vector.getDimensionLabel(d)]*b[Vector.getDimensionLabel(d)]).reduce((a,b)=>a+b,0):void 0}static length(a){return Math.sqrt(Vector.dot(a,a))}static normalise(a){return Vector.div(a,Vector.length(a))}static setLength(a,b){return Vector.mult(Vector.normalise(a),b)}static limit(a,b){let c=Vector.length(a);return c<=b?a:Vector.mult(Vector.normalise(a),b)}static min(a,b){if(Vector.sameDimension(a,b)){let c=Array(vector.dimension).fill(null).map((c,d)=>Math.min(a[Vector.getDimensionLabel(d)],b[Vector.getDimensionLabel(d)]));return new Vector(...c)}}static min(a,b){if(Vector.sameDimension(a,b)){let c=Array(vector.dimension).fill(null).map((c,d)=>Math.max(a[Vector.getDimensionLabel(d)],b[Vector.getDimensionLabel(d)]));return new Vector(...c)}}static lerp(a,b,c){if(Vector.sameDimension(a,b)){let d=Vector.clone(b);return d.subtract(a).multiply(c).add(a)}}static map(a,b,c,d,e){if(Vector.sameDimension(a,b,c,d,e)){let f=Array(a.dimension).fill(null).map((f,g)=>{let h=Vector.getDimensionLabel(g);return d[h]+(a[h]-b[h])*(e[h]-d[h])/(c[h]-b[h])});return new Vector(...f)}}static clone(a){return JSON.parse(JSON.stringify(a))}get dimension(){return Object.keys(this).length}update(a){for(let b in this)a.hasOwnProperty(b)&&(this[b]=a[b]);return this}add(...a){return a.forEach(a=>this.update(Vector.add(this,a))),this}addExact(...a){return a.forEach(a=>this.update(Vector.addExact(this,a))),this}subtract(...a){return a.forEach(a=>this.update(Vector.subtract(this,a))),this}subtractExact(...a){return a.forEach(a=>this.update(Vector.subtractExact(this,a))),this}mult(a){return this.update(Vector.mult(this,a))}div(a){return this.update(Vector.div(this,a))}negative(){return this.update(Vector.negative(this))}dot(a){return Vector.dot(this,a)}length(){return Vector.length(this)}normalise(){return this.update(Vector.normalise(this))}setLength(a){return this.update(Vector.setLength(this,a))}limit(a){return this.update(Vector.limit(this,a))}min(a){return this.update(Vector.min(this,a))}min(a){return this.update(Vector.max(this,a))}lerp(a,b,c){return this.update(Vector.lerp(a,b,c))}map(a,b,c,d){return this.update(Vector.map(this,a,b,c,d))}clone(){return Vector.clone(this)}}"undefined"==typeof exports?window.Vector=Vector:("undefined"!=typeof module&&module.exports&&(exports=module.exports=Vector),exports.Vector=Vector);