var isNumeric=function(...a){return 0===a.filter(a=>"undefined"==typeof a||Array.isArray(a)||isNaN(parseFloat(a))||!isFinite(a)).length},sumExact=function(...a){var b=Math.abs;if(0==a.length)return;if(1==a.length)return a[0];let c=a[0],d=0,e=0;for(let f=1;f<a.length;f++){let g=a[f],h=c+g;if(-1<(g+"").indexOf(".")){let a=(g+"").split(".")[1].length;e=a>e?a:e}d+=b(c)>=b(g)?c-h+g:g-h+c,c=h}let f=Math.pow(10,e+1);return Math.round((c+d)*f)/f};class Matrix{constructor(a=[],b,c){if(this.rows=b||void 0,this.cols=c||void 0,this.values=[],0<a.length){let d=0===a.filter(a=>Array.isArray(a)).length;if(!d||"undefined"!=typeof b&&"undefined"!=typeof c)this.fill(a);else throw new Exception("The shape of the matrix could not be determined because the Matrix class was constructed with a flat data array and without the rows and/or cols parameter. Either construct the Matrix class with a two-dimensional array of data in a well-defined shape, or pass the rows and cols parameter on initialisation.")}}fill(a){let b=0===a.filter(a=>Array.isArray(a)).length;if(b)for(let b,c=0;c<this.rows;c++){b=[];for(let d=0;d<this.cols;d++)b[d]=a[c*this.cols+d]||0;this.values[c]=b}else{let b=0===a.filter(b=>b.length!==a[0].length).length;if(!b){throw new Exception("The shape of the matrix could not be determined because the rows are not of the same length.")}this.rows=a.length,this.cols=a[0].length,this.values=a}return this}update(a){return void 0===typeof a?this:(this.values=a.values,this.rows=a.rows,this.cols=a.cols,this)}static isMatrix(...a){return 0===a.filter(a=>!(a instanceof Matrix)).length}static clone(a){return JSON.parse(JSON.stringify(a))}clone(){return Matrix.clone(this)}static sameShape(a,...b){return Matrix.isMatrix(a,...b)?0==b.filter(b=>b.rows!==a.rows||b.cols!==a.cols).length:void 0}sameShape(...a){return Matrix.sameShape(...a)}static log(a){console.table(a.values)}log(){Matrix.log(this)}static add(...a){return Matrix.sameShape(...a)?new Matrix(Array(a[0].rows).fill(null).map((b,c)=>Array(a[0].cols).fill(null).map((b,d)=>a.reduce((a,b)=>a+b.values[c][d],0)))):void 0}add(...a){return this.update(Matrix.add(this,...a))}static addExact(...a){return Matrix.sameShape(...a)?new Matrix(Array(a[0].rows).fill(null).map((b,c)=>Array(a[0].cols).fill(null).map((b,d)=>sumExact(...a.map(a=>a.values[c][d]))))):void 0}addExact(...a){return this.update(Matrix.addExact(this,...a))}static subtract(a,...b){return Matrix.sameShape(a,...b)?new Matrix(Array(a.rows).fill(null).map((c,d)=>Array(a.cols).fill(null).map((c,e)=>b.reduce((a,b)=>a-b.values[d][e],a.values[d][e])))):void 0}subtract(...a){return this.update(Matrix.subtract(this,...a))}static subtractExact(a,...b){return Matrix.sameShape(a,...b)?new Matrix(Array(a.rows).fill(null).map((c,d)=>Array(a.cols).fill(null).map((a,c)=>sumExact(...b.map((a,b)=>0==b?a.values[d][c]:-a.values[d][c]))))):void 0}subtractExact(...a){return this.update(Matrix.subtractExact(this,...a))}static mult(a,b){return Matrix.isMatrix(a)&&isNumeric(b)?new Matrix(Array(a.rows).fill(null).map((c,d)=>Array(a.cols).fill(null).map((c,e)=>a.values[d][e]*b))):void 0}mult(a){return this.update(Matrix.mult(this,a))}static div(a,b){return Matrix.isMatrix(a)&&isNumeric(b)&&0!=b?new Matrix(Array(a.rows).fill(null).map((c,d)=>Array(a.cols).fill(null).map((c,e)=>a.values[d][e]/b))):void 0}div(a){return this.update(Matrix.div(this,a))}static negative(a){return Matrix.isMatrix(a)?Matrix.mult(a,-1):void 0}negative(){return this.update(Matrix.negative(this))}static matMult(a,b){return Matrix.isMatrix(a,b)&&a.cols===b.rows?new Matrix(Array(a.rows).fill(null).map((c,d)=>Array(b.cols).fill(null).map((c,e)=>Array(a.cols).fill(null).map((c,f)=>a.values[d][f]*b.values[f][e]).reduce((a,b)=>a+b,0)))):void 0}matMult(a){return this.update(Matrix.matMult(this,a))}static submatrix(a,b,c){if(!Matrix.isMatrix(a))return;let d,e=Matrix.clone(a);for(e.values.splice(b,1),d=e.values.length;d--;)e.values[d].splice(c,1);return e.rows=e.cols=e.values.length,e}submatrix(a,b){return Matrix.submatrix(this,a,b)}static determinant(a){if(!Matrix.isMatrix(a)||a.rows!==a.cols)return;if(0==a.rows)return 0;if(1==a.rows)return a.values[0][0];if(2==a.rows)return a.values[0][0]*a.values[1][1]-a.values[0][1]*a.values[1][0];let b=0;for(let c=0;1>c;c++)for(let d,e=0;e<a.rows;e++)d=(c+e)%2?-1:1,b+=d*a.values[c][e]*Matrix.determinant(Matrix.submatrix(a,c,e));return b}determinant(){return Matrix.determinant(this)}}class Vector{constructor(...a){let b=0;a.forEach(function(a){if(isNumeric(a)){let c=Vector.getDimensionLabel(b);this[c]=parseFloat(a),b++}else null!==a&&"object"==typeof a&&this.parseSettings(a)},this),this.x=this.x||0,this.y=this.y||0}parseSettings(a){if(a.dimension&&this.dimension<a.dimension)for(let b,c=this.dimension;c<a.dimension;c++)b=Vector.getDimensionLabel(c),this[b]=0}static getDimensionLabel(a){let b=Array(26).fill("").map((a,b)=>String.fromCharCode(97+b)),c=b.slice(-3).concat(b.slice(0,-3));return 25>=a?c[a]:b[Math.floor(a/25)-1]+b[a%25]}static getDimensionFromLabel(a){let b=Array(26).fill("").map((a,b)=>String.fromCharCode(97+b)),c=b.slice(-3).concat(b.slice(0,-3));return 0===a.length?c.indexOf(a):26*b.indexOf(a.substr(0,1))+b.indexOf(a.substr(1,0))}static getAngleLabel(a){let b=["alpha","beta","gamma","delta","epsilon","zeta","eta","theta","iota","kappa","lambda","mu","nu","xi","omicron","pi","rho","sigma","tau","upsilon","phi","chi","psi","omega"];return 23>=a?b[a]:b[Math.floor(a/23)-1]+b[a%23]}get dimension(){return Object.keys(this).length}update(a){if(typeof a===void 0)return this;for(let b in this)a.hasOwnProperty(b)&&(this[b]=a[b]);return this}static isVector(...a){return 0===a.filter(a=>!(a instanceof Vector)).length}static clone(a){return JSON.parse(JSON.stringify(a))}clone(){return Vector.clone(this)}static sameDimension(a,...b){return Vector.isVector(a,...b)?0==b.filter(b=>b.dimension!==a.dimension).length:void 0}sameDimension(...a){return Vectors.sameDimension(this,...a)}static add(...a){if(Vector.sameDimension(...a)){let b=Array(a[0].dimension).fill(null).map((b,c)=>a.reduce((a,b)=>a+b[Vector.getDimensionLabel(c)],0));return new Vector(...b)}}add(...a){return this.update(Vector.add(this,...a))}static addExact(...a){if(Vector.sameDimension(...a)){let b=Array(a[0].dimension).fill(null).map((b,c)=>sumExact(...a.map(a=>a[Vector.getDimensionLabel(c)])));return new Vector(...b)}}addExact(...a){return this.update(Vector.addExact(this,...a))}static subtract(a,...b){if(Vector.sameDimension(a,...b)){let c=Array(a.dimension).fill(null).map((c,d)=>b.reduce((a,b)=>a-b[Vector.getDimensionLabel(d)],a[Vector.getDimensionLabel(d)]));return new Vector(...c)}}subtract(...a){return this.update(Vector.subtract(this,...a))}static subtractExact(...a){if(Vector.sameDimension(...a)){let b=Array(a[0].dimension).fill(null).map((b,c)=>sumExact(...a.map((a,b)=>0==b?a[Vector.getDimensionLabel(c)]:-a[Vector.getDimensionLabel(c)])));return new Vector(...b)}}subtractExact(...a){return this.update(Vector.subtractExact(this,...a))}static mult(a,b){if(Vector.isVector(a)&&isNumeric(b)){let c=Array(a.dimension).fill(null).map((c,d)=>a[Vector.getDimensionLabel(d)]*b);return new Vector(...c)}}mult(a){return this.update(Vector.mult(this,a))}static div(a,b){if(Vector.isVector(a)&&isNumeric(b)&&0!=b){let c=Array(a.dimension).fill(null).map((c,d)=>a[Vector.getDimensionLabel(d)]/b);return new Vector(...c)}}div(a){return this.update(Vector.div(this,a))}static negative(a){return Vector.isVector(a)?Vector.mult(a,-1):void 0}negative(){return this.update(Vector.negative(this))}static cross(...a){if(!Vector.isVector(...a))return;let b=a[0].dimension;if(a.length===b){let c=Array(b).fill(null).map((c,d)=>Array(b).fill(null).map((b,c)=>a[c][Vector.getDimensionLabel(d)]));return new Matrix(c).determinant()}if(a.length===b-1&&3===b){let b=a[0].y*a[1].z-a[0].z*a[1].y,c=a[0].z*a[1].x-a[0].x*a[1].z,d=a[0].x*a[1].y-a[0].y*a[1].x;return new Vector(b,c,d)}}cross(a){return Vector.cross(this,a)}static dot(a,b){return Vector.sameDimension(a,b)?Array(a.dimension).fill(null).map((c,d)=>a[Vector.getDimensionLabel(d)]*b[Vector.getDimensionLabel(d)]).reduce((a,b)=>a+b,0):void 0}dot(a){return Vector.dot(this,a)}static vectorTripleProduct(a,b,c){if(Vector.isVector(a,b,c)){let d=Vector.cross(b,c);return d?Vector.cross(a,d):void 0}}vectorTripleProduct(a,b){return Vector.vectorTripleProduct(this,a,b)}static scalarTripleProduct(a,b,c){if(Vector.isVector(a,b,c)){let d=Vector.cross(a,b);return d?Vector.dot(d,c):void 0}}scalarTripleProduct(a,b){return Vector.scalarTripleProduct(this,a,b)}static dyadic(a,b){if(Vector.isVector(a,b)){let c=Array(a.dimension).fill(null).map((c,d)=>Array(b.dimension).fill(null).map((c,e)=>a[Vector.getDimensionLabel(d)]*b[Vector.getDimensionLabel(e)]));return new Matrix(c)}}dyadic(a){return Vector.dyadic(this,a)}static matMult(a,b){if(Vector.isVector(a)&&Matrix.isMatrix(b)&&a.dimension===b.rows){let c=new Matrix([Array(a.dimension).fill(null).map(()=>a[Vector.getDimensionLabeldim])]),d=Matrix.matMult(c,b);return new Vector(...d.values[0])}}matMult(a){return this.update(Vector.matMult(this,a))}static angle(a,b){if(Vector.sameDimension(a,b)){let c=Vector.length(a),d=Vector.length(b);return 0===c||0===d?void 0:Math.acos(Vector.dot(a,b)/(c*d))}}angle(a){return Vector.angle(this,a)}static angleToAxis(a,b){if(Vector.isVector(a)){let c=Array(a.dimension).fill(0);return c["string"==typeof b?Vector.getDimensionFromLabel(b):b]=1,Vector.angle(a,new Vector(...c))}}angleToAxis(a){return Vector.angleToAxis(vector,a)}static angleX(a){return Vector.angleToAxis(a,0)}angleX(){return Vector.angleX(this)}static angleY(a){return Vector.angleToAxis(a,1)}angleY(){return Vector.angleY(this)}static angleZ(a){return Vector.angleToAxis(a,2)}angleZ(){return Vector.angleZs(this)}static rotate(a,b,c=!1){return Vector.isVector(a)&&isNumeric(b)?3===a.dimension?Vector.rotateAxis(a,b,c):2===a.dimension?Vector.rotatePoint(a,b,c||new Vector(0,0)):void 0:void 0}rotate(a,b=!1){return this.update(Vector.roate(this,a,b))}static rotatePoint(a,b,c=!1){var d=Math.sin,e=Math.cos;if(Vector.isVector(a)&&isNumeric(b)){c=c||new Vector(0,0);let f=a.clone(),g=new Matrix([[e(b),-d(b)],[d(b),e(b)]]);return f.subtract(c).matMult(g).add(c)}}rotatePoint(a,b=!1){return this.update(Vector.rotatePoint(this,a,b))}static rotateX(a,b){var c=Math.sin,d=Math.cos;if(Vector.isVector(a)&&isNumeric(b)){let e=new Matrix([[1,0,0],[0,d(b),-c(b)],[0,c(b),d(b)]]);return Vector.matMult(a,e)}}rotateX(a){return this.update(Vector.rotateX(this,a))}static rotateY(a,b){var c=Math.sin,d=Math.cos;if(Vector.isVector(a)&&isNumeric(b)){let e=new Matrix([[d(b),0,c(b)],[0,1,0],[-c(b),0,d(b)]]);return Vector.matMult(a,e)}}rotateY(a){return this.update(Vector.rotateY(this,a))}static rotateZ(a,b){var c=Math.sin,d=Math.cos;if(Vector.isVector(a)&&isNumeric(b)){let e=new Matrix([[d(b),-c(b),0],[c(b),d(b),0],[0,0,1]]);return Vector.matMult(a,e)}}rotateZ(a){return this.update(Vector.rotateZ(this,a))}static rotateAxis(a,b,c){if(Vector.isVector(a)&&isNumeric(b)){if("x"===c)return Vector.rotateX(a,b);if("y"===c)return Vector.rotateY(a,b);if("z"===c)return Vector.rotateZ(a,b);if(Vector.isVector(c)&&3===a.dimension){let d=Math.cos(b),e=Math.sin(b),f=1-d,g=new Matrix([[c.x*c.x*f+d,c.y*c.x*f-c.z*e,c.x*c.z*f+c.y*e],[c.x*c.y*f+c.z*e,c.y*c.y*f+d,c.y*c.z*f-c.x*e],[c.x*c.z*f-c.y*e,c.y*c.z*f+c.x*e,c.z*c.z*f+d]]);return Vector.matMult(a,g)}}}rotateAxis(a,b){return this.update(Vector.rotateAxis(this,a,b))}static length(a){return Vector.isVector(a)?Math.sqrt(Vector.dot(a,a)):void 0}length(){return Vector.length(this)}static normalise(a){return Vector.isVector(a)?Vector.div(a,Vector.length(a)):void 0}normalise(){return this.update(Vector.normalise(this))}static setLength(a,b){return Vector.isVector(a)&&isNumeric(b)?Vector.mult(Vector.normalise(a),b):void 0}setLength(a){return this.update(Vector.setLength(this,a))}static limit(a,b){if(Vector.isVector(a)&&isNumeric(b)){let c=Vector.length(a);return c<=b?a:Vector.mult(Vector.normalise(a),b)}}limit(a){return this.update(Vector.limit(this,a))}static reduce(a){var b=Math.abs;if(!Vector.isVector(a))return;if(Object.keys(a).some(b=>a[b]-parseInt(0!==a[b])))return a;let c=a.dimension,d=[];for(let c=0;c<a.dimension-2;c++)for(let e=c+1;e<a.dimension;e++){let f=b(a[Vector.getDimensionLabel(c)]),g=b(a[Vector.getDimensionLabel(e)]);if(f<g){let a=f;f=g,g=a}for(let a=f%g;0!==a&&1<g;)f=g,g=a,a=f%g;1<g&&-1===d.indexOf(g)&&d.push(g)}if(0===d.length)return a;d.sort().reverse();for(let b=0;b<d.length;b++)if(0===Object.keys(a).filter(c=>0!=a[c]%d[b]).length)return Vector.div(a,d[b]);return a}reduce(){return this.update(Vector.reduce(this))}static min(a,b){if(Vector.sameDimension(a,b)){let c=Array(vector.dimension).fill(null).map((c,d)=>Math.min(a[Vector.getDimensionLabel(d)],b[Vector.getDimensionLabel(d)]));return new Vector(...c)}}min(a){return this.update(Vector.min(this,a))}static max(a,b){if(Vector.sameDimension(a,b)){let c=Array(vector.dimension).fill(null).map((c,d)=>Math.max(a[Vector.getDimensionLabel(d)],b[Vector.getDimensionLabel(d)]));return new Vector(...c)}}min(a){return this.update(Vector.max(this,a))}static lerp(a,b,c){if(Vector.sameDimension(a,b)){let d=Vector.clone(b);return d.subtract(a).multiply(c).add(a)}}lerp(a,b,c){return this.update(Vector.lerp(a,b,c))}static map(a,b,c,d,e){if(Vector.sameDimension(a,b,c,d,e)){let f=Array(a.dimension).fill(null).map((f,g)=>{let h=Vector.getDimensionLabel(g);return d[h]+(a[h]-b[h])*(e[h]-d[h])/(c[h]-b[h])});return new Vector(...f)}}map(a,b,c,d){return this.update(Vector.map(this,a,b,c,d))}static distance(a,b){return Vector.sameDimension(a,b)?Math.sqrt(Vector.distanceSquared(a,b)):void 0}distance(a){return Vector.distance(this,a)}static distanceSquared(a,b){return Vector.sameDimension(a,b)?Object.keys(a).map(c=>Math.pow(a[c]-b[c],2)).reduce((a,b)=>a+b,0):void 0}distanceSquared(a){return Vector.distanceSquared(this,a)}static distanceManhattan(a,b){return Vector.sameDimension(a,b)?Object.keys(a).map(c=>Math.abs(a[c]-b[c])).reduce((a,b)=>a+b,0):void 0}distanceManhattan(a){return Vector.distanceManhattan(this,a)}static distanceChebyshev(a,b){if(!Vector.sameDimension(a,b))return;let c=0;return Object.keys(a).forEach(d=>c=Math.max(c,Math.abs(a[d]-b[d]))),c}distanceChebyshev(a){return Vector.distanceChebyshev(this,a)}static distanceMinkowski(a,b,c=2){var d=Math.pow;return 0!=c&&Vector.sameDimension(a,b)?d(Object.keys(a).map(e=>d(a[e]-b[e],c)).reduce((a,b)=>a+b,0),1/c):void 0}distanceMinkowski(a,b=2){return Vector.distanceMinkowski(this,a,b)}static toPolar(a){var b=Math.acos;if(!Vector.isVector(a))return;let c=a.dimensions;if(2==c)return{radius:a.length(),alpha:Math.atan2(a.y,a.x)};if(3==c)return{radius:a.length(),alpha:b(a.z/a.length()),beta:Math.atan(a.y/a.x)};let d=Vector.length(a),e=Array(c-1).fill(null).map((d,e)=>{let f=a[Vector.getDimensionLabel(e)],g=null,h=0;for(let b,f=c-1;f>=e;f--)b=a[Vector.getDimensionLabel(f)],g=0===b?f:g,h+=Math.pow(b,2);return null===g?(0>f&&e===c-2?-1:1)*b(f/Math.sqrt(h)):0<a[Vector.getDimensionLabel(g-1)]?0:Math.PI}),f={radius:d};return e.forEach((a,b)=>f[Vector.getAngleLabel(b)]=a),f}toPolar(){return Vector.toPolar(this)}static fromPolar(a,...b){var c=Math.sin,d=Math.cos;if(0===b.length)return;if(!isNumeric(a,...b))return;let e=b.length+1;if(2===e)return new Vector(a*d(b[0]),a*c(b[0]));if(3===e)return new Vector(a*c(b[0])*d(b[1]),a*c(b[0])*c(b[1]),a*d(b[0]));else{Array(e).fill(null).map((f,g)=>{let h=a*Array(g).fill(null).map((a,d)=>c(b[g-d-1])).reduce((a,b)=>a*b,1);return g===e-1?h*=c(b[g]):0<g&&(h*=d(b[g])),h});return new Vector(...cords)}}}"undefined"==typeof exports?window.Vector=Vector:("undefined"!=typeof module&&module.exports&&(exports=module.exports=Vector),exports.Vector=Vector);