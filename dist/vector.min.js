var isNumeric=function(a){return"undefined"==typeof a?void 0:!Array.isArray(a)&&!isNaN(parseFloat(a))&&isFinite(a)},sumExact=function(a){var b=Math.abs;if(0==a.length)return;if(1==a.length)return a[0];let c=a[0],d=0,e=0;for(let f=1;f<a.length;f++){let g=a[f],h=c+g;if(-1<(g+"").indexOf(".")){let a=(g+"").split(".")[1].length;e=a>e?a:e}d+=b(c)>=b(g)?c-h+g:g-h+c,c=h}let f=Math.pow(10,e+1);return Math.round((c+d)*f)/f};class Matrix{constructor(a=[],b,c){if(this.rows=b||void 0,this.cols=c||void 0,this.values=[],0<a.length){let d=0===a.filter(a=>Array.isArray(a)).length;if(!d||"undefined"!=typeof b&&"undefined"!=typeof c)this.fill(a);else throw new Exception("The shape of the matrix could not be determined because the Matrix class was constructed with a flat data array and without the rows and/or cols parameter. Either construct the Matrix class with a two-dimensional array of data in a well-defined shape, or pass the rows and cols parameter on initialisation.")}}fill(a){let b=0===a.filter(a=>Array.isArray(a)).length;if(b)for(let b,c=0;c<this.rows;c++){b=[];for(let d=0;d<this.cols;d++)b[d]=a[c*this.cols+d]||0;this.values[c]=b}else{let b=0===a.filter(b=>b.length!==a[0].length).length;if(!b){throw new Exception("The shape of the matrix could not be determined because the rows are not of the same length.")}this.rows=a.length,this.cols=a[0].length,this.values=a}return this}static submatrix(a,b,c){let d,e=Matrix.clone(a);for(e.values.splice(b,1),d=e.values.length;d--;)e.values[d].splice(c,1);return e.rows=e.cols=e.values.length,e}static determinant(a){if(a.rows!==a.cols)return;if(0==a.rows)return 0;if(1==a.rows)return a.values[0][0];if(2==a.rows)return a.values[0][0]*a.values[1][1]-a.values[0][1]*a.values[1][0];let b=0;for(let c=0;1>c;c++)for(let d,e=0;e<a.rows;e++)d=(c+e)%2?-1:1,b+=d*a.values[c][e]*Matrix.determinant(Matrix.submatrix(a,c,e));return b}static clone(a){return JSON.parse(JSON.stringify(a))}determinant(){return Matrix.determinant(this)}submatrix(a,b){return Matrix.submatrix(this,a,b)}clone(){return Matrix.clone(this)}}class Vector{constructor(...a){let b=0;a.forEach(function(a){if(isNumeric(a)){let c=Vector.getDimensionLabel(b);this[c]=parseFloat(a),b++}else null!==a&&"object"==typeof a&&this.parseSettings(a)},this),this.x=this.x||0,this.y=this.y||0}parseSettings(a){if(a.dimension&&this.dimension<a.dimension)for(let b,c=this.dimension;c<a.dimension;c++)b=Vector.getDimensionLabel(c),this[b]=0}static getDimensionLabel(a){let b=Array(26).fill("").map((a,b)=>String.fromCharCode(97+b)),c=b.slice(-3).concat(b.slice(0,-3));return 25>=a?c[a]:b[Math.floor(a/25)-1]+b[a%25]}static getAngleLabel(a){let b=["alpha","beta","gamma","delta","epsilon","zeta","eta","theta","iota","kappa","lambda","mu","nu","xi","omicron","pi","rho","sigma","tau","upsilon","phi","chi","psi","omega"];return 23>=a?b[a]:b[Math.floor(a/23)-1]+b[a%23]}static clone(a){return JSON.parse(JSON.stringify(a))}static sameDimension(a,...b){return 0==b.filter(b=>b.dimension!==a.dimension).length}static add(...a){if(Vector.sameDimension(...a)){let b=Array(a[0].dimension).fill(null).map((b,c)=>a.reduce((a,b)=>a+b[Vector.getDimensionLabel(c)],0));return new Vector(...b)}}static addExact(...a){if(Vector.sameDimension(...a)){let b=Array(a[0].dimension).fill(null).map((b,c)=>sumExact(a.map(a=>a[Vector.getDimensionLabel(c)])));return new Vector(...b)}}static subtract(a,...b){if(Vector.sameDimension(a,...b)){let c=Array(a.dimension).fill(null).map((c,d)=>b.reduce((a,b)=>a-b[Vector.getDimensionLabel(d)],a[Vector.getDimensionLabel(d)]));return new Vector(...c)}}static subtractExact(...a){if(Vector.sameDimension(...a)){let b=Array(a[0].dimension).fill(null).map((b,c)=>sumExact(a.map((a,b)=>0==b?a[Vector.getDimensionLabel(c)]:-a[Vector.getDimensionLabel(c)])));return new Vector(...b)}}static mult(a,b){let c=Array(a.dimension).fill(null).map((c,d)=>a[Vector.getDimensionLabel(d)]*b);return new Vector(...c)}static div(a,b){if(0!=b){let c=Array(a.dimension).fill(null).map((c,d)=>a[Vector.getDimensionLabel(d)]/b);return new Vector(...c)}}static negative(a){return Vector.mult(a,-1)}static cross(...a){let b=a[0].dimension;if(a.length===b){let c=Array(b).fill(null).map((c,d)=>Array(b).fill(null).map((b,c)=>a[c][Vector.getDimensionLabel(d)]));return new Matrix(c).determinant()}if(a.length===b-1&&3===b){let b=a[0].y*a[1].z-a[0].z*a[1].y,c=a[0].z*a[1].x-a[0].x*a[1].z,d=a[0].x*a[1].y-a[0].y*a[1].x;return new Vector(b,c,d)}}static dot(a,b){return Vector.sameDimension(a,b)?Array(a.dimension).fill(null).map((c,d)=>a[Vector.getDimensionLabel(d)]*b[Vector.getDimensionLabel(d)]).reduce((a,b)=>a+b,0):void 0}static angle(a,b){if(Vector.sameDimension(a,b)){let c=Vector.length(a),d=Vector.length(b);return 0===c||0===d?void 0:Math.acos(Vector.dot(a,b)/(c*d))}}static length(a){return Math.sqrt(Vector.dot(a,a))}static normalise(a){return Vector.div(a,Vector.length(a))}static setLength(a,b){return Vector.mult(Vector.normalise(a),b)}static limit(a,b){let c=Vector.length(a);return c<=b?a:Vector.mult(Vector.normalise(a),b)}static reduce(a){var b=Math.abs;if(Object.keys(a).some(b=>a[b]-parseInt(0!==a[b])))return a;let c=a.dimension,d=[];for(let c=0;c<a.dimension-2;c++)for(let e=c+1;e<a.dimension;e++){let f=b(a[Vector.getDimensionLabel(c)]),g=b(a[Vector.getDimensionLabel(e)]);if(f<g){let a=f;f=g,g=a}for(let a=f%g;0!==a&&1<g;)f=g,g=a,a=f%g;1<g&&-1===d.indexOf(g)&&d.push(g)}if(0===d.length)return a;d.sort().reverse();for(let b=0;b<d.length;b++)if(0===Object.keys(a).filter(c=>0!=a[c]%d[b]).length)return Vector.div(a,d[b]);return a}static min(a,b){if(Vector.sameDimension(a,b)){let c=Array(vector.dimension).fill(null).map((c,d)=>Math.min(a[Vector.getDimensionLabel(d)],b[Vector.getDimensionLabel(d)]));return new Vector(...c)}}static min(a,b){if(Vector.sameDimension(a,b)){let c=Array(vector.dimension).fill(null).map((c,d)=>Math.max(a[Vector.getDimensionLabel(d)],b[Vector.getDimensionLabel(d)]));return new Vector(...c)}}static lerp(a,b,c){if(Vector.sameDimension(a,b)){let d=Vector.clone(b);return d.subtract(a).multiply(c).add(a)}}static map(a,b,c,d,e){if(Vector.sameDimension(a,b,c,d,e)){let f=Array(a.dimension).fill(null).map((f,g)=>{let h=Vector.getDimensionLabel(g);return d[h]+(a[h]-b[h])*(e[h]-d[h])/(c[h]-b[h])});return new Vector(...f)}}static distance(a,b){return Vector.sameDimension(a,b)?Math.sqrt(Vector.distanceSquared(a,b)):void 0}static distanceSquared(a,b){return Vector.sameDimension(a,b)?Object.keys(a).map(c=>Math.pow(a[c]-b[c],2)).reduce((a,b)=>a+b,0):void 0}static distanceManhattan(a,b){return Vector.sameDimension(a,b)?Object.keys(a).map(c=>Math.abs(a[c]-b[c])).reduce((a,b)=>a+b,0):void 0}static distanceChebyshev(a,b){if(!Vector.sameDimension(a,b))return;let c=0;return Object.keys(a).forEach(d=>c=Math.max(c,Math.abs(a[d]-b[d]))),c}static distanceMinkowski(a,b,c=2){var d=Math.pow;return 0!=c&&Vector.sameDimension(a,b)?d(Object.keys(a).map(e=>d(a[e]-b[e],c)).reduce((a,b)=>a+b,0),1/c):void 0}get dimension(){return Object.keys(this).length}clone(){return Vector.clone(this)}update(a){for(let b in this)a.hasOwnProperty(b)&&(this[b]=a[b]);return this}add(...a){return a.forEach(a=>this.update(Vector.add(this,a))),this}addExact(...a){return a.forEach(a=>this.update(Vector.addExact(this,a))),this}subtract(...a){return a.forEach(a=>this.update(Vector.subtract(this,a))),this}subtractExact(...a){return a.forEach(a=>this.update(Vector.subtractExact(this,a))),this}mult(a){return this.update(Vector.mult(this,a))}div(a){return this.update(Vector.div(this,a))}negative(){return this.update(Vector.negative(this))}cross(a){return Vector.cross(this,a)}dot(a){return Vector.dot(this,a)}angle(a){return Vector.angle(this,a)}length(){return Vector.length(this)}normalise(){return this.update(Vector.normalise(this))}setLength(a){return this.update(Vector.setLength(this,a))}limit(a){return this.update(Vector.limit(this,a))}reduce(){return this.update(Vector.reduce(this))}min(a){return this.update(Vector.min(this,a))}min(a){return this.update(Vector.max(this,a))}lerp(a,b,c){return this.update(Vector.lerp(a,b,c))}map(a,b,c,d){return this.update(Vector.map(this,a,b,c,d))}distance(a){return Vector.distance(this,a)}distanceSquared(a){return Vector.distanceSquared(this,a)}distanceManhattan(a){return Vector.distanceManhattan(this,a)}distanceChebyshev(a){return Vector.distanceChebyshev(this,a)}distanceMinkowski(a,b=2){return Vector.distanceMinkowski(this,a,b)}}"undefined"==typeof exports?window.Vector=Vector:("undefined"!=typeof module&&module.exports&&(exports=module.exports=Vector),exports.Vector=Vector);