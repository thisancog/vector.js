var isNumeric=function(a){return"undefined"==typeof a?void 0:!Array.isArray(a)&&!isNaN(parseFloat(a))&&isFinite(a)},sumExact=function(a){var b=Math.abs;if(0==a.length)return;if(1==a.length)return a[0];let c=a[0],d=0,e=0;for(let f=1;f<a.length;f++){let g=a[f],h=c+g;if(-1<(g+"").indexOf(".")){let a=(g+"").split(".")[1].length;e=a>e?a:e}d+=b(c)>=b(g)?c-h+g:g-h+c,c=h}let f=Math.pow(10,e+1);return Math.round((c+d)*f)/f};class Matrix{constructor(a=[],b,c){if(this.rows=b||void 0,this.cols=c||void 0,this.values=[],0<a.length){let d=0===a.filter(a=>Array.isArray(a)).length;if(!d||"undefined"!=typeof b&&"undefined"!=typeof c)this.fill(a);else throw new Exception("The shape of the matrix could not be determined because the Matrix class was constructed with a flat data array and without the rows and/or cols parameter. Either construct the Matrix class with a two-dimensional array of data in a well-defined shape, or pass the rows and cols parameter on initialisation.")}}fill(a){let b=0===a.filter(a=>Array.isArray(a)).length;if(b)for(let b,c=0;c<this.rows;c++){b=[];for(let d=0;d<this.cols;d++)b[d]=a[c*this.cols+d]||0;this.values[c]=b}else{let b=0===a.filter(b=>b.length!==a[0].length).length;if(!b){throw new Exception("The shape of the matrix could not be determined because the rows are not of the same length.")}this.rows=a.length,this.cols=a[0].length,this.values=a}return this}static isMatrix(...a){return 0===a.filter(a=>!(a instanceof Matrix)).length}static clone(a){return JSON.parse(JSON.stringify(a))}static sameShape(a,...b){return Matrix.isMatrix(a,...b)?0==b.filter(b=>b.rows!==a.rows||b.cols!==a.cols).length:void 0}static log(a){console.table(a.values)}static add(...a){return Matrix.sameShape(...a)?new Matrix(Array(a[0].rows).fill(null).map((b,c)=>Array(a[0].cols).fill(null).map((b,d)=>a.reduce((a,b)=>a+b.values[c][d],0)))):void 0}static addExact(...a){return Matrix.sameShape(...a)?new Matrix(Array(a[0].rows).fill(null).map((b,c)=>Array(a[0].cols).fill(null).map((b,d)=>sumExact(a.map(a=>a.values[c][d]))))):void 0}static subtract(a,...b){return Matrix.sameShape(a,...b)?new Matrix(Array(a.rows).fill(null).map((c,d)=>Array(a.cols).fill(null).map((c,e)=>b.reduce((a,b)=>a-b.values[d][e],a.values[d][e])))):void 0}static subtractExact(a,...b){return Matrix.sameShape(a,...b)?new Matrix(Array(a.rows).fill(null).map((c,d)=>Array(a.cols).fill(null).map((a,c)=>sumExact(b.map((a,b)=>0==b?a.values[d][c]:-a.values[d][c]))))):void 0}static mult(a,b){return Matrix.isMatrix(a)&&isNumeric(b)?new Matrix(Array(a.rows).fill(null).map((c,d)=>Array(a.cols).fill(null).map((c,e)=>a.values[d][e]*b))):void 0}static div(a,b){return Matrix.isMatrix(a)&&isNumeric(b)&&0!=b?new Matrix(Array(a.rows).fill(null).map((c,d)=>Array(a.cols).fill(null).map((c,e)=>a.values[d][e]/b))):void 0}static matMult(a,b){return Matrix.isMatrix(a,b)&&a.cols===b.rows?new Matrix(Array(a.rows).fill(null).map((c,d)=>Array(b.cols).fill(null).map((c,e)=>Array(a.cols).fill(null).map((c,f)=>a.values[d][f]*b.values[f][e]).reduce((a,b)=>a+b,0)))):void 0}static submatrix(a,b,c){if(!Matrix.isMatrix(a))return;let d,e=Matrix.clone(a);for(e.values.splice(b,1),d=e.values.length;d--;)e.values[d].splice(c,1);return e.rows=e.cols=e.values.length,e}static determinant(a){if(!Matrix.isMatrix(a)||a.rows!==a.cols)return;if(0==a.rows)return 0;if(1==a.rows)return a.values[0][0];if(2==a.rows)return a.values[0][0]*a.values[1][1]-a.values[0][1]*a.values[1][0];let b=0;for(let c=0;1>c;c++)for(let d,e=0;e<a.rows;e++)d=(c+e)%2?-1:1,b+=d*a.values[c][e]*Matrix.determinant(Matrix.submatrix(a,c,e));return b}update(a){return void 0===typeof a?this:(this.values=a.values,this.rows=a.rows,this.cols=a.cols,this)}clone(){return Matrix.clone(this)}log(){Matrix.log(this)}add(...a){return this.update(Matrix.add(this,...a))}addExact(...a){return this.update(Matrix.addExact(this,...a))}subtract(...a){return this.update(Matrix.subtract(this,...a))}subtractExact(...a){return this.update(Matrix.subtractExact(this,...a))}mult(a){return this.update(Matrix.mult(this,a))}div(a){return this.update(Matrix.div(this,a))}matMult(a){return this.update(Matrix.matMult(this,a))}submatrix(a,b){return Matrix.submatrix(this,a,b)}determinant(){return Matrix.determinant(this)}}class Vector{constructor(...a){let b=0;a.forEach(function(a){if(isNumeric(a)){let c=Vector.getDimensionLabel(b);this[c]=parseFloat(a),b++}else null!==a&&"object"==typeof a&&this.parseSettings(a)},this),this.x=this.x||0,this.y=this.y||0}parseSettings(a){if(a.dimension&&this.dimension<a.dimension)for(let b,c=this.dimension;c<a.dimension;c++)b=Vector.getDimensionLabel(c),this[b]=0}static getDimensionLabel(a){let b=Array(26).fill("").map((a,b)=>String.fromCharCode(97+b)),c=b.slice(-3).concat(b.slice(0,-3));return 25>=a?c[a]:b[Math.floor(a/25)-1]+b[a%25]}static getDimensionFromLabel(a){let b=Array(26).fill("").map((a,b)=>String.fromCharCode(97+b)),c=b.slice(-3).concat(b.slice(0,-3));return 0===a.length?c.indexOf(a):26*b.indexOf(a.substr(0,1))+b.indexOf(a.substr(1,0))}static getAngleLabel(a){let b=["alpha","beta","gamma","delta","epsilon","zeta","eta","theta","iota","kappa","lambda","mu","nu","xi","omicron","pi","rho","sigma","tau","upsilon","phi","chi","psi","omega"];return 23>=a?b[a]:b[Math.floor(a/23)-1]+b[a%23]}static isVector(...a){return 0===a.filter(a=>!(a instanceof Vector)).length}static clone(a){return JSON.parse(JSON.stringify(a))}static sameDimension(a,...b){return Vector.isVector(a,...b)?0==b.filter(b=>b.dimension!==a.dimension).length:void 0}static add(...a){if(Vector.sameDimension(...a)){let b=Array(a[0].dimension).fill(null).map((b,c)=>a.reduce((a,b)=>a+b[Vector.getDimensionLabel(c)],0));return new Vector(...b)}}static addExact(...a){if(Vector.sameDimension(...a)){let b=Array(a[0].dimension).fill(null).map((b,c)=>sumExact(a.map(a=>a[Vector.getDimensionLabel(c)])));return new Vector(...b)}}static subtract(a,...b){if(Vector.sameDimension(a,...b)){let c=Array(a.dimension).fill(null).map((c,d)=>b.reduce((a,b)=>a-b[Vector.getDimensionLabel(d)],a[Vector.getDimensionLabel(d)]));return new Vector(...c)}}static subtractExact(...a){if(Vector.sameDimension(...a)){let b=Array(a[0].dimension).fill(null).map((b,c)=>sumExact(a.map((a,b)=>0==b?a[Vector.getDimensionLabel(c)]:-a[Vector.getDimensionLabel(c)])));return new Vector(...b)}}static mult(a,b){if(Vector.isVector(a)&&isNumeric(b)){let c=Array(a.dimension).fill(null).map((c,d)=>a[Vector.getDimensionLabel(d)]*b);return new Vector(...c)}}static div(a,b){if(Vector.isVector(a)&&isNumeric(b)&&0!=b){let c=Array(a.dimension).fill(null).map((c,d)=>a[Vector.getDimensionLabel(d)]/b);return new Vector(...c)}}static negative(a){return Vector.isVector(a)?Vector.mult(a,-1):void 0}static cross(...a){if(!Vector.isVector(...a))return;let b=a[0].dimension;if(a.length===b){let c=Array(b).fill(null).map((c,d)=>Array(b).fill(null).map((b,c)=>a[c][Vector.getDimensionLabel(d)]));return new Matrix(c).determinant()}if(a.length===b-1&&3===b){let b=a[0].y*a[1].z-a[0].z*a[1].y,c=a[0].z*a[1].x-a[0].x*a[1].z,d=a[0].x*a[1].y-a[0].y*a[1].x;return new Vector(b,c,d)}}static dot(a,b){return Vector.sameDimension(a,b)?Array(a.dimension).fill(null).map((c,d)=>a[Vector.getDimensionLabel(d)]*b[Vector.getDimensionLabel(d)]).reduce((a,b)=>a+b,0):void 0}static vectorTripleProduct(a,b,c){if(Vector.isVector(a,b,c)){let d=Vector.cross(b,c);return d?Vector.cross(a,d):void 0}}static scalarTripleProduct(a,b,c){if(Vector.isVector(a,b,c)){let d=Vector.cross(a,b);return d?Vector.dot(d,c):void 0}}static dyadic(a,b){if(Vector.isVector(a,b)){let c=Array(a.dimension).fill(null).map((c,d)=>Array(b.dimension).fill(null).map((c,e)=>a[Vector.getDimensionLabel(d)]*b[Vector.getDimensionLabel(e)]));return new Matrix(c)}}static matMult(a,b){if(Vector.isVector(a)&&Matrix.isMatrix(b)&&a.dimension===b.rows){let c=new Matrix([Array(a.dimension).fill(null).map(()=>a[Vector.getDimensionLabeldim])]),d=Matrix.matMult(c,b);return new Vector(...d.values[0])}}static angle(a,b){if(Vector.sameDimension(a,b)){let c=Vector.length(a),d=Vector.length(b);return 0===c||0===d?void 0:Math.acos(Vector.dot(a,b)/(c*d))}}static angleToAxis(a,b){if(Vector.isVector(a)){let c=Array(a.dimension).fill(0);return c["string"==typeof b?Vector.getDimensionFromLabel(b):b]=1,Vector.angle(a,new Vector(...c))}}static angleX(a){return Vector.angleToAxis(a,0)}static angleY(a){return Vector.angleToAxis(a,1)}static angleZ(a){return Vector.angleToAxis(a,2)}static length(a){return Vector.isVector(a)?Math.sqrt(Vector.dot(a,a)):void 0}static normalise(a){return Vector.isVector(a)?Vector.div(a,Vector.length(a)):void 0}static setLength(a,b){return Vector.isVector(a)&&isNumeric(b)?Vector.mult(Vector.normalise(a),b):void 0}static limit(a,b){if(Vector.isVector(a)&&isNumeric(b)){let c=Vector.length(a);return c<=b?a:Vector.mult(Vector.normalise(a),b)}}static reduce(a){var b=Math.abs;if(!Vector.isVector(a))return;if(Object.keys(a).some(b=>a[b]-parseInt(0!==a[b])))return a;let c=a.dimension,d=[];for(let c=0;c<a.dimension-2;c++)for(let e=c+1;e<a.dimension;e++){let f=b(a[Vector.getDimensionLabel(c)]),g=b(a[Vector.getDimensionLabel(e)]);if(f<g){let a=f;f=g,g=a}for(let a=f%g;0!==a&&1<g;)f=g,g=a,a=f%g;1<g&&-1===d.indexOf(g)&&d.push(g)}if(0===d.length)return a;d.sort().reverse();for(let b=0;b<d.length;b++)if(0===Object.keys(a).filter(c=>0!=a[c]%d[b]).length)return Vector.div(a,d[b]);return a}static min(a,b){if(Vector.sameDimension(a,b)){let c=Array(vector.dimension).fill(null).map((c,d)=>Math.min(a[Vector.getDimensionLabel(d)],b[Vector.getDimensionLabel(d)]));return new Vector(...c)}}static max(a,b){if(Vector.sameDimension(a,b)){let c=Array(vector.dimension).fill(null).map((c,d)=>Math.max(a[Vector.getDimensionLabel(d)],b[Vector.getDimensionLabel(d)]));return new Vector(...c)}}static lerp(a,b,c){if(Vector.sameDimension(a,b)){let d=Vector.clone(b);return d.subtract(a).multiply(c).add(a)}}static map(a,b,c,d,e){if(Vector.sameDimension(a,b,c,d,e)){let f=Array(a.dimension).fill(null).map((f,g)=>{let h=Vector.getDimensionLabel(g);return d[h]+(a[h]-b[h])*(e[h]-d[h])/(c[h]-b[h])});return new Vector(...f)}}static distance(a,b){return Vector.sameDimension(a,b)?Math.sqrt(Vector.distanceSquared(a,b)):void 0}static distanceSquared(a,b){return Vector.sameDimension(a,b)?Object.keys(a).map(c=>Math.pow(a[c]-b[c],2)).reduce((a,b)=>a+b,0):void 0}static distanceManhattan(a,b){return Vector.sameDimension(a,b)?Object.keys(a).map(c=>Math.abs(a[c]-b[c])).reduce((a,b)=>a+b,0):void 0}static distanceChebyshev(a,b){if(!Vector.sameDimension(a,b))return;let c=0;return Object.keys(a).forEach(d=>c=Math.max(c,Math.abs(a[d]-b[d]))),c}static distanceMinkowski(a,b,c=2){var d=Math.pow;return 0!=c&&Vector.sameDimension(a,b)?d(Object.keys(a).map(e=>d(a[e]-b[e],c)).reduce((a,b)=>a+b,0),1/c):void 0}get dimension(){return Object.keys(this).length}clone(){return Vector.clone(this)}update(a){if(typeof a===void 0)return this;for(let b in this)a.hasOwnProperty(b)&&(this[b]=a[b]);return this}add(...a){return this.update(Vector.add(this,...a))}addExact(...a){return this.update(Vector.addExact(this,...a))}subtract(...a){return this.update(Vector.subtract(this,...a))}subtractExact(...a){return this.update(Vector.subtractExact(this,...a))}mult(a){return this.update(Vector.mult(this,a))}div(a){return this.update(Vector.div(this,a))}negative(){return this.update(Vector.negative(this))}cross(a){return Vector.cross(this,a)}dot(a){return Vector.dot(this,a)}vectorTripleProduct(a,b){return Vector.vectorTripleProduct(this,a,b)}scalarTripleProduct(a,b){return Vector.scalarTripleProduct(this,a,b)}dyadic(a){return Vector.dyadic(this,a)}matMult(a){return this.update(Vector.matMult(this,a))}angle(a){return Vector.angle(this,a)}angleToAxis(a){return Vector.angleToAxis(vector,a)}angleX(){return Vector.angleX(this)}angleY(){return Vector.angleY(this)}angleZ(){return Vector.angleZs(this)}length(){return Vector.length(this)}normalise(){return this.update(Vector.normalise(this))}setLength(a){return this.update(Vector.setLength(this,a))}limit(a){return this.update(Vector.limit(this,a))}reduce(){return this.update(Vector.reduce(this))}min(a){return this.update(Vector.min(this,a))}min(a){return this.update(Vector.max(this,a))}lerp(a,b,c){return this.update(Vector.lerp(a,b,c))}map(a,b,c,d){return this.update(Vector.map(this,a,b,c,d))}distance(a){return Vector.distance(this,a)}distanceSquared(a){return Vector.distanceSquared(this,a)}distanceManhattan(a){return Vector.distanceManhattan(this,a)}distanceChebyshev(a){return Vector.distanceChebyshev(this,a)}distanceMinkowski(a,b=2){return Vector.distanceMinkowski(this,a,b)}}"undefined"==typeof exports?window.Vector=Vector:("undefined"!=typeof module&&module.exports&&(exports=module.exports=Vector),exports.Vector=Vector);